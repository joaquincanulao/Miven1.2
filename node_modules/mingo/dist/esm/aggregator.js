import {
  getOperator,
  initOptions,
<<<<<<< HEAD
  OperatorType,
=======
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
  ProcessingMode
} from "./core";
import { Lazy } from "./lazy";
import { assert, cloneDeep, intersection, isEmpty } from "./util";
class Aggregator {
<<<<<<< HEAD
  constructor(pipeline, options) {
    this.pipeline = pipeline;
    this.options = initOptions(options);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
=======
  #pipeline;
  #options;
  constructor(pipeline, options) {
    this.#pipeline = pipeline;
    this.#options = initOptions(options);
  }
  /**
   * Returns an {@link Iterator} for lazy evaluation of the pipeline.
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
<<<<<<< HEAD
  stream(collection) {
    let iterator = Lazy(collection);
    const mode = this.options.processingMode;
    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {
      iterator.map(cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!isEmpty(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = getOperator(
          OperatorType.PIPELINE,
          opName,
          this.options
        );
=======
  stream(collection, options) {
    let iterator = Lazy(collection);
    const opts = options ?? this.#options;
    const mode = opts.processingMode;
    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {
      iterator.map(cloneDeep);
    }
    const stages = new Array();
    if (!isEmpty(this.#pipeline)) {
      for (const operator of this.#pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = getOperator("pipeline", opName, opts);
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
        assert(
          operatorKeys.length === 1 && !!call,
          `invalid pipeline operator ${opName}`
        );
<<<<<<< HEAD
        pipelineOperators.push(opName);
        iterator = call(iterator, operator[opName], this.options);
      }
    }
    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([["$group", "$unwind"], pipelineOperators]).length) {
=======
        stages.push(opName);
        iterator = call(iterator, operator[opName], opts);
      }
    }
    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([["$group", "$unwind"], stages]).length) {
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
      iterator.map(cloneDeep);
    }
    return iterator;
  }
  /**
   * Return the results of the aggregation as an array.
   *
<<<<<<< HEAD
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
=======
   * @param collection
   */
  run(collection, options) {
    return this.stream(collection, options).value();
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
  }
}
export {
  Aggregator
};
