import type { TSESTree } from '../ts-estree';
declare const isOptionalChainPunctuator: (token: TSESTree.Token | null | undefined) => token is {
    value: "?.";
} & TSESTree.PunctuatorToken;
<<<<<<< HEAD
<<<<<<< HEAD
declare const isNotOptionalChainPunctuator: (token: TSESTree.Token | null | undefined) => token is Exclude<TSESTree.Token, {
    value: "?.";
} & TSESTree.PunctuatorToken>;
declare const isNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is {
    value: "!";
} & TSESTree.PunctuatorToken;
declare const isNotNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is Exclude<TSESTree.Token, {
    value: "!";
} & TSESTree.PunctuatorToken>;
=======
=======
>>>>>>> cfa17b8e4 (favorite)
declare const isNotOptionalChainPunctuator: (token: TSESTree.Token | null | undefined) => token is TSESTree.BooleanToken | TSESTree.BlockComment | TSESTree.LineComment | TSESTree.IdentifierToken | TSESTree.JSXIdentifierToken | TSESTree.JSXTextToken | TSESTree.KeywordToken | TSESTree.NullToken | TSESTree.NumericToken | TSESTree.PunctuatorToken | TSESTree.RegularExpressionToken | TSESTree.StringToken | TSESTree.TemplateToken;
declare const isNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is {
    value: "!";
} & TSESTree.PunctuatorToken;
declare const isNotNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is TSESTree.BooleanToken | TSESTree.BlockComment | TSESTree.LineComment | TSESTree.IdentifierToken | TSESTree.JSXIdentifierToken | TSESTree.JSXTextToken | TSESTree.KeywordToken | TSESTree.NullToken | TSESTree.NumericToken | TSESTree.PunctuatorToken | TSESTree.RegularExpressionToken | TSESTree.StringToken | TSESTree.TemplateToken;
<<<<<<< HEAD
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
=======
>>>>>>> cfa17b8e4 (favorite)
/**
 * Returns true if and only if the node represents: foo?.() or foo.bar?.()
 */
declare const isOptionalCallExpression: (node: TSESTree.Node | null | undefined) => node is {
    optional: boolean;
} & TSESTree.CallExpression;
/**
 * Returns true if and only if the node represents logical OR
 */
declare const isLogicalOrOperator: (node: TSESTree.Node | null | undefined) => node is Partial<TSESTree.LogicalExpression> & TSESTree.LogicalExpression;
/**
 * Checks if a node is a type assertion:
 * ```
 * x as foo
 * <foo>x
 * ```
 */
<<<<<<< HEAD
<<<<<<< HEAD
declare const isTypeAssertion: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.TSAsExpression | TSESTree.AST_NODE_TYPES.TSTypeAssertion;
}>;
declare const isVariableDeclarator: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.VariableDeclarator;
}>;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.ArrowFunctionExpression | TSESTree.AST_NODE_TYPES.FunctionDeclaration | TSESTree.AST_NODE_TYPES.FunctionExpression;
}>;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.TSCallSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSConstructorType | TSESTree.AST_NODE_TYPES.TSConstructSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSDeclareFunction | TSESTree.AST_NODE_TYPES.TSEmptyBodyFunctionExpression | TSESTree.AST_NODE_TYPES.TSFunctionType | TSESTree.AST_NODE_TYPES.TSMethodSignature;
}>;
declare const isFunctionOrFunctionType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.ArrowFunctionExpression | TSESTree.AST_NODE_TYPES.FunctionDeclaration | TSESTree.AST_NODE_TYPES.FunctionExpression | TSESTree.AST_NODE_TYPES.TSCallSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSConstructorType | TSESTree.AST_NODE_TYPES.TSConstructSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSDeclareFunction | TSESTree.AST_NODE_TYPES.TSEmptyBodyFunctionExpression | TSESTree.AST_NODE_TYPES.TSFunctionType | TSESTree.AST_NODE_TYPES.TSMethodSignature;
}>;
declare const isTSFunctionType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.TSFunctionType;
}>;
declare const isTSConstructorType: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.TSConstructorType;
}>;
declare const isClassOrTypeElement: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.FunctionExpression | TSESTree.AST_NODE_TYPES.MethodDefinition | TSESTree.AST_NODE_TYPES.PropertyDefinition | TSESTree.AST_NODE_TYPES.TSAbstractMethodDefinition | TSESTree.AST_NODE_TYPES.TSAbstractPropertyDefinition | TSESTree.AST_NODE_TYPES.TSCallSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSConstructSignatureDeclaration | TSESTree.AST_NODE_TYPES.TSEmptyBodyFunctionExpression | TSESTree.AST_NODE_TYPES.TSIndexSignature | TSESTree.AST_NODE_TYPES.TSMethodSignature | TSESTree.AST_NODE_TYPES.TSPropertySignature;
}>;
=======
=======
>>>>>>> cfa17b8e4 (favorite)
declare const isTypeAssertion: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSTypeAssertion;
declare const isVariableDeclarator: (node: TSESTree.Node | null | undefined) => node is TSESTree.VariableDeclaratorDefiniteAssignment | TSESTree.VariableDeclaratorMaybeInit | TSESTree.VariableDeclaratorNoInit | TSESTree.UsingInForOfDeclarator | TSESTree.UsingInNormalContextDeclarator;
declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;
declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructorType | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;
declare const isFunctionOrFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructorType | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;
declare const isTSFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSFunctionType;
declare const isTSConstructorType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSConstructorType;
declare const isClassOrTypeElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.FunctionExpression | TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName | TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName | TSESTree.TSAbstractMethodDefinitionComputedName | TSESTree.TSAbstractMethodDefinitionNonComputedName | TSESTree.TSAbstractPropertyDefinitionComputedName | TSESTree.TSAbstractPropertyDefinitionNonComputedName | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSIndexSignature | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName | TSESTree.TSPropertySignatureComputedName | TSESTree.TSPropertySignatureNonComputedName;
<<<<<<< HEAD
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
=======
>>>>>>> cfa17b8e4 (favorite)
/**
 * Checks if a node is a constructor method.
 */
declare const isConstructor: (node: TSESTree.Node | null | undefined) => node is Partial<TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName> & (TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName);
/**
 * Checks if a node is a setter method.
 */
declare function isSetter(node: TSESTree.Node | undefined): node is {
    kind: 'set';
} & (TSESTree.MethodDefinition | TSESTree.Property);
<<<<<<< HEAD
<<<<<<< HEAD
declare const isIdentifier: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.Identifier;
}>;
/**
 * Checks if a node represents an `await …` expression.
 */
declare const isAwaitExpression: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.AwaitExpression;
}>;
=======
=======
>>>>>>> cfa17b8e4 (favorite)
declare const isIdentifier: (node: TSESTree.Node | null | undefined) => node is TSESTree.Identifier;
/**
 * Checks if a node represents an `await …` expression.
 */
declare const isAwaitExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.AwaitExpression;
<<<<<<< HEAD
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
=======
>>>>>>> cfa17b8e4 (favorite)
/**
 * Checks if a possible token is the `await` keyword.
 */
declare const isAwaitKeyword: (token: TSESTree.Token | null | undefined) => token is {
    value: "await";
} & TSESTree.IdentifierToken;
/**
 * Checks if a possible token is the `type` keyword.
 */
declare const isTypeKeyword: (token: TSESTree.Token | null | undefined) => token is {
    value: "type";
} & TSESTree.IdentifierToken;
/**
 * Checks if a possible token is the `import` keyword.
 */
declare const isImportKeyword: (token: TSESTree.Token | null | undefined) => token is {
    value: "import";
} & TSESTree.KeywordToken;
<<<<<<< HEAD
<<<<<<< HEAD
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is Extract<TSESTree.Node, {
    type: TSESTree.AST_NODE_TYPES.DoWhileStatement | TSESTree.AST_NODE_TYPES.ForInStatement | TSESTree.AST_NODE_TYPES.ForOfStatement | TSESTree.AST_NODE_TYPES.ForStatement | TSESTree.AST_NODE_TYPES.WhileStatement;
}>;
=======
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
>>>>>>> 7cb31df57 (se integro la edicion de las recetas)
=======
declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;
>>>>>>> cfa17b8e4 (favorite)
export { isAwaitExpression, isAwaitKeyword, isClassOrTypeElement, isConstructor, isFunction, isFunctionOrFunctionType, isFunctionType, isIdentifier, isImportKeyword, isLogicalOrOperator, isLoop, isNonNullAssertionPunctuator, isNotNonNullAssertionPunctuator, isNotOptionalChainPunctuator, isOptionalCallExpression, isOptionalChainPunctuator, isSetter, isTSConstructorType, isTSFunctionType, isTypeAssertion, isTypeKeyword, isVariableDeclarator, };
//# sourceMappingURL=predicates.d.ts.map