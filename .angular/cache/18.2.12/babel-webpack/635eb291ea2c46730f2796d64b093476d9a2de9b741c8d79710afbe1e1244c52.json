{"ast":null,"code":"import _asyncToGenerator from \"/home/jcanulao/Documentos/Miven1.0.0-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _RecipeService;\nimport { combineLatest } from 'rxjs';\nimport firebase from 'firebase/compat/app';\nimport { switchMap, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"@angular/fire/compat/auth\";\nexport class RecipeService {\n  constructor(firestore, auth) {\n    this.firestore = firestore;\n    this.auth = auth;\n  }\n  // Método para agregar una receta a Firestore\n  addRecipe(recipe) {\n    return this.firestore.collection('recetas').add(recipe);\n  }\n  // Método para obtener todas las recetas\n  getAllRecipes() {\n    return this.firestore.collection('recetas').valueChanges({\n      idField: 'id'\n    });\n  }\n  // Método para obtener recetas por categoría\n  getRecipesByCategory(category) {\n    return this.firestore.collection('recetas', ref => ref.where('categoria', '==', category)).valueChanges({\n      idField: 'id'\n    });\n  }\n  // Método para eliminar una receta\n  deleteRecipe(recipeId) {\n    return this.firestore.collection('recetas').doc(recipeId).delete();\n  }\n  // Método para obtener comentarios con detalles de usuarios\n  getRecipeCommentsWithUser(recipeId) {\n    return this.firestore.collection('recetas').doc(recipeId).collection('comentarios', ref => ref.orderBy('timestamp', 'desc')).snapshotChanges().pipe(switchMap(actions => {\n      const userObservables = actions.map(a => {\n        const data = a.payload.doc.data();\n        const id = a.payload.doc.id;\n        // Obtener detalles adicionales del usuario\n        return this.firestore.collection('usuarios').doc(data.userId).get().pipe(map(userDoc => {\n          const userData = userDoc.data() || {};\n          return {\n            ...data,\n            id,\n            userName: userData.nombre || 'Usuario Anónimo',\n            timestamp: data.timestamp.toDate()\n          };\n        }));\n      });\n      return combineLatest(userObservables);\n    }));\n  }\n  // Método para agregar un comentario con calificación a una receta\n  addCommentWithRating(recipeId, userId, rating, comment) {\n    var _this = this;\n    return this.firestore.firestore.runTransaction( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (transaction) {\n        var _data$ratingCount, _data$ratingTotal;\n        const recipeRef = _this.firestore.collection('recetas').doc(recipeId).ref;\n        const recipeDoc = yield transaction.get(recipeRef);\n        if (!recipeDoc.exists) {\n          throw new Error(\"Receta no encontrada\");\n        }\n        // Obtener los datos existentes de la receta\n        const data = recipeDoc.data() || {};\n        const ratingCount = (_data$ratingCount = data.ratingCount) !== null && _data$ratingCount !== void 0 ? _data$ratingCount : 0;\n        const ratingTotal = (_data$ratingTotal = data.ratingTotal) !== null && _data$ratingTotal !== void 0 ? _data$ratingTotal : 0;\n        const newRatingCount = ratingCount + 1;\n        const newRatingTotal = ratingTotal + rating;\n        const newAverageRating = newRatingTotal / newRatingCount;\n        // Actualizar la receta con el nuevo promedio y conteo de calificaciones\n        transaction.update(recipeRef, {\n          ratingCount: newRatingCount,\n          ratingTotal: newRatingTotal,\n          rating: newAverageRating // Promedio de las calificaciones\n        });\n        // Añadir el comentario a la subcolección de comentarios\n        const commentRef = _this.firestore.collection('recetas').doc(recipeId).collection('comentarios').doc();\n        transaction.set(commentRef.ref, {\n          userId,\n          rating,\n          // Calificación proporcionada\n          comment,\n          // Comentario del usuario\n          timestamp: firebase.firestore.FieldValue.serverTimestamp()\n        });\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n  markAsFavorite(recipeId, userId, isFavorite) {\n    return this.firestore.collection('usuarios').doc(userId).collection('favoritos').doc(recipeId).set({\n      favorita: isFavorite\n    });\n  }\n  getFavoriteRecipes(userId) {\n    return this.firestore.collection('usuarios').doc(userId).collection('favoritos').valueChanges();\n  }\n  getRecipeById(recipeId) {\n    return this.firestore.collection('recetas').doc(recipeId).valueChanges().pipe(\n    // Filtra valores undefined\n    map(recipe => {\n      if (!recipe) {\n        throw new Error(`Receta con ID ${recipeId} no encontrada`);\n      }\n      return recipe;\n    }));\n  }\n  updateRecipe(recipeId, recipeData) {\n    return this.firestore.collection('recetas').doc(recipeId).update(recipeData);\n  }\n}\n_RecipeService = RecipeService;\n_RecipeService.ɵfac = function RecipeService_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || _RecipeService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.AngularFireAuth));\n};\n_RecipeService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _RecipeService,\n  factory: _RecipeService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["combineLatest","firebase","switchMap","map","RecipeService","constructor","firestore","auth","addRecipe","recipe","collection","add","getAllRecipes","valueChanges","idField","getRecipesByCategory","category","ref","where","deleteRecipe","recipeId","doc","delete","getRecipeCommentsWithUser","orderBy","snapshotChanges","pipe","actions","userObservables","a","data","payload","id","userId","get","userDoc","userData","userName","nombre","timestamp","toDate","addCommentWithRating","rating","comment","_this","runTransaction","_ref","_asyncToGenerator","transaction","_data$ratingCount","_data$ratingTotal","recipeRef","recipeDoc","exists","Error","ratingCount","ratingTotal","newRatingCount","newRatingTotal","newAverageRating","update","commentRef","set","FieldValue","serverTimestamp","_x","apply","arguments","markAsFavorite","isFavorite","favorita","getFavoriteRecipes","getRecipeById","updateRecipe","recipeData","i0","ɵɵinject","i1","AngularFirestore","i2","AngularFireAuth","factory","ɵfac","providedIn"],"sources":["/home/jcanulao/Documentos/Miven1.0.0-main/src/app/services/recipe.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { AngularFirestore } from '@angular/fire/compat/firestore';\nimport { AngularFireAuth } from '@angular/fire/compat/auth';\nimport { Observable, combineLatest } from 'rxjs';\nimport firebase from 'firebase/compat/app';\nimport { switchMap, map } from 'rxjs/operators';\n\n\nexport interface Ingredient {\n  nombre: string;\n  cantidad: number;\n  unidad: string;\n}\n\nexport interface Recipe {\n  titulo: string;\n  descripcion: string;\n  categoria: string;\n  ingredientes: Ingredient[]; \n  creadorId: string;\n  imageUrl?: string | null;\n  favorita?: boolean;\n}\n\ninterface Comment {\n  userId: string;\n  rating: number;\n  comment: string;\n  timestamp: firebase.firestore.Timestamp;\n}\n\ninterface UserData {\n  nombre: string;\n  [key: string]: any; \n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RecipeService {\n  constructor(private firestore: AngularFirestore, private auth: AngularFireAuth) {}\n\n  // Método para agregar una receta a Firestore\n  addRecipe(recipe: Recipe) {\n    return this.firestore.collection('recetas').add(recipe);\n  }\n\n  // Método para obtener todas las recetas\n  getAllRecipes(): Observable<any[]> {\n    return this.firestore.collection('recetas').valueChanges({ idField: 'id' });\n  }\n\n  // Método para obtener recetas por categoría\n  getRecipesByCategory(category: string): Observable<any[]> {\n    return this.firestore.collection('recetas', ref => ref.where('categoria', '==', category)).valueChanges({ idField: 'id' });\n  }\n\n  // Método para eliminar una receta\n  deleteRecipe(recipeId: string) {\n    return this.firestore.collection('recetas').doc(recipeId).delete();\n  }\n\n\n\n  // Método para obtener comentarios con detalles de usuarios\n  getRecipeCommentsWithUser(recipeId: string): Observable<any[]> {\n    return this.firestore.collection('recetas').doc(recipeId).collection('comentarios', ref => ref.orderBy('timestamp', 'desc')).snapshotChanges().pipe(\n      switchMap(actions => {\n        const userObservables = actions.map(a => {\n          const data = a.payload.doc.data() as Comment;\n          const id = a.payload.doc.id;\n  \n          // Obtener detalles adicionales del usuario\n          return this.firestore.collection('usuarios').doc(data.userId).get().pipe(\n            map((userDoc: any) => {\n              const userData = userDoc.data() || {};\n              return {\n                ...data,\n                id,\n                userName: userData.nombre || 'Usuario Anónimo',\n                timestamp: data.timestamp.toDate()\n              };\n            })\n          );\n        });\n  \n        return combineLatest(userObservables);\n      })\n    );\n  }\n\n  // Método para agregar un comentario con calificación a una receta\n  addCommentWithRating(recipeId: string, userId: string, rating: number, comment: string) {\n    return this.firestore.firestore.runTransaction(async (transaction: firebase.firestore.Transaction) => {\n      const recipeRef = this.firestore.collection('recetas').doc(recipeId).ref;\n      const recipeDoc = await transaction.get(recipeRef);\n\n      if (!recipeDoc.exists) {\n        throw new Error(\"Receta no encontrada\");\n      }\n\n      // Obtener los datos existentes de la receta\n      const data: { ratingCount?: number; ratingTotal?: number} = recipeDoc.data() || {};\n\n      const ratingCount = data.ratingCount ?? 0;\n      const ratingTotal = data.ratingTotal ?? 0;\n\n      const newRatingCount = ratingCount + 1;\n      const newRatingTotal = ratingTotal + rating;\n      const newAverageRating = newRatingTotal / newRatingCount;\n\n      // Actualizar la receta con el nuevo promedio y conteo de calificaciones\n      transaction.update(recipeRef, {\n        ratingCount: newRatingCount,\n        ratingTotal: newRatingTotal,\n        rating: newAverageRating // Promedio de las calificaciones\n      });\n\n      // Añadir el comentario a la subcolección de comentarios\n      const commentRef = this.firestore.collection('recetas').doc(recipeId).collection('comentarios').doc();\n      transaction.set(commentRef.ref, {\n        userId,\n        rating, // Calificación proporcionada\n        comment, // Comentario del usuario\n        timestamp: firebase.firestore.FieldValue.serverTimestamp()\n      });\n    });\n  }\n\n  markAsFavorite(recipeId: string, userId: string, isFavorite: boolean) {\n    return this.firestore.collection('usuarios')\n      .doc(userId)\n      .collection('favoritos')\n      .doc(recipeId)\n      .set({ favorita: isFavorite });\n  }\n\n  getFavoriteRecipes(userId: string) {\n    return this.firestore.collection('usuarios').doc(userId).collection('favoritos').valueChanges();\n  }\n  getRecipeById(recipeId: string): Observable<Recipe> {\n    return this.firestore\n      .collection('recetas')\n      .doc<Recipe>(recipeId)\n      .valueChanges()\n      .pipe(\n        // Filtra valores undefined\n        map((recipe) => {\n          if (!recipe) {\n            throw new Error(`Receta con ID ${recipeId} no encontrada`);\n          }\n          return recipe;\n        })\n      );\n  }\n  \n\n  updateRecipe(recipeId: string, recipeData: Recipe): Promise<void> {\n    return this.firestore.collection('recetas').doc(recipeId).update(recipeData);\n  }\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}