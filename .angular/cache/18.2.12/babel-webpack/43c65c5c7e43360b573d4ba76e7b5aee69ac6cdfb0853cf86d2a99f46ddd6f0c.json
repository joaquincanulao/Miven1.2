{"ast":null,"code":"import _defineProperty from \"/home/jcanulao/Documentos/Miven1.0.0-main/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _AngularFirestore, _AngularFirestoreModule;\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i3 from '@angular/fire/app-check';\nimport { ɵfirebaseAppFactory as _firebaseAppFactory, ɵcacheInstance as _cacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory as _authFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport { Observable, asyncScheduler, from, of } from 'rxjs';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport firebase from 'firebase/compat/app';\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n  return new Observable(subscriber => {\n    let unsubscribe;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(snapshots => {\n    const [priorPayload, payload] = snapshots;\n    if (!payload.exists) {\n      return {\n        payload,\n        type: 'removed'\n      };\n    }\n    if (!(priorPayload !== null && priorPayload !== void 0 && priorPayload.exists)) {\n      return {\n        payload,\n        type: 'added'\n      };\n    }\n    return {\n      payload,\n      type: 'modified'\n    };\n  }));\n}\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(payload => ({\n    payload,\n    type: 'query'\n  })));\n}\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nclass AngularFirestoreDocument {\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(ref, afs) {\n    _defineProperty(this, \"ref\", void 0);\n    _defineProperty(this, \"afs\", void 0);\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data, options) {\n    return this.ref.set(data, options);\n  }\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data) {\n    return this.ref.update(data);\n  }\n  /**\n   * Delete a document.\n   */\n  delete() {\n    return this.ref.delete();\n  }\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection(path, queryFn) {\n    const collectionRef = this.ref.collection(path);\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges() {\n    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    return this.snapshotChanges().pipe(map(({\n      payload\n    }) => options.idField ? {\n      ...payload.data(),\n      ...{\n        [options.idField]: payload.id\n      }\n    } : payload.data()));\n  }\n  /**\n   * Retrieve the document once.\n   */\n  get(options) {\n    return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n  }\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(actionTuple => {\n    const [priorAction, action] = actionTuple;\n    const docChanges = action.payload.docChanges();\n    const actions = docChanges.map(change => ({\n      type: change.type,\n      payload: change\n    }));\n    // the metadata has changed from the prior emission\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach((currentDoc, currentIndex) => {\n        const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n        const priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n          // document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n    return actions;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(),\n  // cut down on unneed change cycles\n  map(changes => changes.map(c => ({\n    type: c.type,\n    payload: c\n  }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nfunction combineChanges(current, changes, events) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollection {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(ref, query, afs) {\n    _defineProperty(this, \"ref\", void 0);\n    _defineProperty(this, \"query\", void 0);\n    _defineProperty(this, \"afs\", void 0);\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events) {\n    let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n    if (events && events.length > 0) {\n      source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n    }\n    return source.pipe(\n    // We want to filter out empty arrays, but always emit at first, so the developer knows\n    // that the collection has been resolve; even if it's empty\n    startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([, current]) => current), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return {\n          ...a.data(),\n          ...{\n            [options.idField]: a.id\n          }\n        };\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data) {\n    return this.ref.add(data);\n  }\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc(path) {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n  }\n}\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollectionGroup {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(query, afs) {\n    _defineProperty(this, \"query\", void 0);\n    _defineProperty(this, \"afs\", void 0);\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n    }\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n  valueChanges(options = {}) {\n    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$.pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return {\n          [options.idField]: a.id,\n          ...a.data()\n        };\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n}\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return {\n    query,\n    ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nclass AngularFirestore {\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(options, name, shouldEnablePersistence, settings,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings,\n  // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n    _defineProperty(this, \"schedulers\", void 0);\n    _defineProperty(this, \"firestore\", void 0);\n    _defineProperty(this, \"persistenceEnabled$\", void 0);\n    this.schedulers = schedulers;\n    const app = _firebaseAppFactory(options, zone, name);\n    const useEmulator = _useEmulator;\n    if (auth) {\n      _authFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n    }\n    [this.firestore, this.persistenceEnabled$] = _cacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n      if (settings) {\n        firestore.settings(settings);\n      }\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') {\n              console.warn(e);\n            }\n            return of(false);\n          }\n        };\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n  collection(pathOrRef, queryFn) {\n    let collectionRef;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection(refInZone, query, this);\n  }\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup(collectionId, queryGroupFn) {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n  }\n  doc(pathOrRef) {\n    let ref;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument(refInZone, this);\n  }\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n}\n_AngularFirestore = AngularFirestore;\n_defineProperty(AngularFirestore, \"\\u0275fac\", function _AngularFirestore_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || _AngularFirestore)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AngularFireAuth, 8), i0.ɵɵinject(USE_EMULATOR$1, 8), i0.ɵɵinject(SETTINGS$1, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i3.AppCheckInstances, 8));\n});\n_defineProperty(AngularFirestore, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _AngularFirestore,\n  factory: _AngularFirestore.ɵfac,\n  providedIn: 'any'\n}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestore, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [FIREBASE_OPTIONS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [FIREBASE_APP_NAME]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ENABLE_PERSISTENCE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [SETTINGS]\n    }]\n  }, {\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i1.ɵAngularFireSchedulers\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [PERSISTENCE_SETTINGS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR]\n    }]\n  }, {\n    type: i2.AngularFireAuth,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_EMULATOR$1]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [SETTINGS$1]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [TENANT_ID]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [LANGUAGE_CODE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [USE_DEVICE_LANGUAGE]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [PERSISTENCE]\n    }]\n  }, {\n    type: i3.AppCheckInstances,\n    decorators: [{\n      type: Optional\n    }]\n  }], null);\n})();\nclass AngularFirestoreModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n  }\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings) {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [{\n        provide: ENABLE_PERSISTENCE,\n        useValue: true\n      }, {\n        provide: PERSISTENCE_SETTINGS,\n        useValue: persistenceSettings\n      }]\n    };\n  }\n}\n_AngularFirestoreModule = AngularFirestoreModule;\n_defineProperty(AngularFirestoreModule, \"\\u0275fac\", function _AngularFirestoreModule_Factory(__ngFactoryType__) {\n  return new (__ngFactoryType__ || _AngularFirestoreModule)();\n});\n_defineProperty(AngularFirestoreModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: _AngularFirestoreModule\n}));\n_defineProperty(AngularFirestoreModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [AngularFirestore]\n}));\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [AngularFirestore]\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };","map":{"version":3,"names":["isPlatformServer","i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","NgModule","i1","keepUnstableUntilFirst","VERSION","i3","ɵfirebaseAppFactory","_firebaseAppFactory","ɵcacheInstance","_cacheInstance","FIREBASE_OPTIONS","FIREBASE_APP_NAME","i2","ɵauthFactory","_authFactory","USE_EMULATOR","USE_EMULATOR$1","SETTINGS","SETTINGS$1","TENANT_ID","LANGUAGE_CODE","USE_DEVICE_LANGUAGE","PERSISTENCE","Observable","asyncScheduler","from","of","startWith","pairwise","map","scan","distinctUntilChanged","filter","firebase","_fromRef","ref","scheduler","subscriber","unsubscribe","schedule","onSnapshot","includeMetadataChanges","fromRef","fromDocRef","pipe","undefined","snapshots","priorPayload","payload","exists","type","fromCollectionRef","AngularFirestoreDocument","constructor","afs","_defineProperty","set","data","options","update","delete","collection","path","queryFn","collectionRef","query","associateQuery","AngularFirestoreCollection","snapshotChanges","scheduledFromDocRef$","schedulers","outsideAngular","valueChanges","idField","id","get","docChanges","actionTuple","priorAction","action","actions","change","JSON","stringify","metadata","docs","forEach","currentDoc","currentIndex","docChange","find","d","doc","isEqual","priorDoc","push","oldIndex","newIndex","sortedChanges","events","current","changes","combineChanges","it","c","indexOf","combineChange","sliceAndSplice","original","start","deleteCount","args","returnArray","slice","splice","combined","copiedArray","validateEventsArray","length","stateChanges","source","prior","auditTrail","validatedEvents","scheduledSortedChanges$","a","add","AngularFirestoreCollectionGroup","fromCollectionRefScheduled$","ENABLE_PERSISTENCE","PERSISTENCE_SETTINGS","AngularFirestore","name","shouldEnablePersistence","settings","platformId","zone","persistenceSettings","_useEmulator","auth","useAuthEmulator","authSettings","tenantId","languageCode","useDeviceLanguage","persistence","_appCheckInstances","app","useEmulator","firestore","persistenceEnabled$","runOutsideAngular","enablePersistence","then","e","console","warn","pathOrRef","refInZone","ngZone","run","collectionGroup","collectionId","queryGroupFn","createId","_AngularFirestore","_AngularFirestore_Factory","__ngFactoryType__","ɵɵinject","NgZone","ɵAngularFireSchedulers","AngularFireAuth","AppCheckInstances","ɵɵdefineInjectable","token","factory","ɵfac","providedIn","ngDevMode","ɵsetClassMetadata","decorators","Object","AngularFirestoreModule","registerVersion","full","ngModule","providers","provide","useValue","_AngularFirestoreModule","_AngularFirestoreModule_Factory","ɵɵdefineNgModule","ɵɵdefineInjector"],"sources":["/home/jcanulao/Documentos/Miven1.0.0-main/node_modules/@angular/fire/fesm2022/angular-fire-compat-firestore.mjs"],"sourcesContent":["import { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i3 from '@angular/fire/app-check';\nimport { ɵfirebaseAppFactory as _firebaseAppFactory, ɵcacheInstance as _cacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory as _authFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport { Observable, asyncScheduler, from, of } from 'rxjs';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport firebase from 'firebase/compat/app';\n\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n    return new Observable(subscriber => {\n        let unsubscribe;\n        if (scheduler != null) {\n            scheduler.schedule(() => {\n                unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n            });\n        }\n        else {\n            unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n        }\n        return () => {\n            if (unsubscribe != null) {\n                unsubscribe();\n            }\n        };\n    });\n}\nfunction fromRef(ref, scheduler) {\n    return _fromRef(ref, scheduler);\n}\nfunction fromDocRef(ref, scheduler) {\n    return fromRef(ref, scheduler)\n        .pipe(startWith(undefined), pairwise(), map((snapshots) => {\n        const [priorPayload, payload] = snapshots;\n        if (!payload.exists) {\n            return { payload, type: 'removed' };\n        }\n        if (!priorPayload?.exists) {\n            return { payload, type: 'added' };\n        }\n        return { payload, type: 'modified' };\n    }));\n}\nfunction fromCollectionRef(ref, scheduler) {\n    return fromRef(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nclass AngularFirestoreDocument {\n    ref;\n    afs;\n    /**\n     * The constructor takes in a DocumentReference to provide wrapper methods\n     * for data operations, data streaming, and Symbol.observable.\n     */\n    constructor(ref, afs) {\n        this.ref = ref;\n        this.afs = afs;\n    }\n    /**\n     * Create or overwrite a single document.\n     */\n    set(data, options) {\n        return this.ref.set(data, options);\n    }\n    /**\n     * Update some fields of a document without overwriting the entire document.\n     */\n    update(data) {\n        return this.ref.update(data);\n    }\n    /**\n     * Delete a document.\n     */\n    delete() {\n        return this.ref.delete();\n    }\n    /**\n     * Create a reference to a sub-collection given a path and an optional query\n     * function.\n     */\n    collection(path, queryFn) {\n        const collectionRef = this.ref.collection(path);\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n    /**\n     * Listen to snapshot updates from the document.\n     */\n    snapshotChanges() {\n        const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n        return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        return this.snapshotChanges().pipe(map(({ payload }) => options.idField ? {\n            ...payload.data(),\n            ...{ [options.idField]: payload.id }\n        } : payload.data()));\n    }\n    /**\n     * Retrieve the document once.\n     */\n    get(options) {\n        return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n    }\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nfunction docChanges(query, scheduler) {\n    return fromCollectionRef(query, scheduler)\n        .pipe(startWith(undefined), pairwise(), map((actionTuple) => {\n        const [priorAction, action] = actionTuple;\n        const docChanges = action.payload.docChanges();\n        const actions = docChanges.map(change => ({ type: change.type, payload: change }));\n        // the metadata has changed from the prior emission\n        if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n            // go through all the docs in payload and figure out which ones changed\n            action.payload.docs.forEach((currentDoc, currentIndex) => {\n                const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n                const priorDoc = priorAction?.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n                if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) ||\n                    !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n                    // document doesn't appear to have changed, don't log another action\n                }\n                else {\n                    // since the actions are processed in order just push onto the array\n                    actions.push({\n                        type: 'modified',\n                        payload: {\n                            oldIndex: currentIndex,\n                            newIndex: currentIndex,\n                            type: 'modified',\n                            doc: currentDoc\n                        }\n                    });\n                }\n            });\n        }\n        return actions;\n    }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nfunction sortedChanges(query, events, scheduler) {\n    return docChanges(query, scheduler)\n        .pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(), // cut down on unneed change cycles\n    map(changes => changes.map(c => ({ type: c.type, payload: c }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nfunction combineChanges(current, changes, events) {\n    changes.forEach(change => {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = combineChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n    const returnArray = original.slice();\n    returnArray.splice(start, deleteCount, ...args);\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nfunction combineChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n                // Not sure why the duplicates are getting fired\n            }\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    const copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n\nfunction validateEventsArray(events) {\n    if (!events || events.length === 0) {\n        events = ['added', 'removed', 'modified'];\n    }\n    return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollection {\n    ref;\n    query;\n    afs;\n    /**\n     * The constructor takes in a CollectionReference and Query to provide wrapper methods\n     * for data operations and data streaming.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query. See the AssociatedRefence type for details\n     * on this implication.\n     */\n    constructor(ref, query, afs) {\n        this.ref = ref;\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     */\n    stateChanges(events) {\n        let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n        if (events && events.length > 0) {\n            source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n        }\n        return source.pipe(\n        // We want to filter out empty arrays, but always emit at first, so the developer knows\n        // that the collection has been resolve; even if it's empty\n        startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([, current]) => current), keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     */\n    snapshotChanges(events) {\n        const validatedEvents = validateEventsArray(events);\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map(actions => actions.payload.docs.map(a => {\n            if (options.idField) {\n                return {\n                    ...a.data(),\n                    ...{ [options.idField]: a.id }\n                };\n            }\n            else {\n                return a.data();\n            }\n        })), keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n    }\n    /**\n     * Add data to a collection reference.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query.\n     */\n    add(data) {\n        return this.ref.add(data);\n    }\n    /**\n     * Create a reference to a single document in a collection.\n     */\n    doc(path) {\n        // TODO is there a better way to solve this type issue\n        return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n    }\n}\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollectionGroup {\n    query;\n    afs;\n    /**\n     * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n     * for data operations and data streaming.\n     */\n    constructor(query, afs) {\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     */\n    stateChanges(events) {\n        if (!events || events.length === 0) {\n            return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n        }\n        return docChanges(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     */\n    snapshotChanges(events) {\n        const validatedEvents = validateEventsArray(events);\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n        return fromCollectionRefScheduled$\n            .pipe(map(actions => actions.payload.docs.map(a => {\n            if (options.idField) {\n                return {\n                    [options.idField]: a.id,\n                    ...a.data()\n                };\n            }\n            else {\n                return a.data();\n            }\n        })), keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n    }\n}\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n    const query = queryFn(collectionRef);\n    const ref = collectionRef;\n    return { query, ref };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nclass AngularFirestore {\n    schedulers;\n    firestore;\n    persistenceEnabled$;\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     */\n    constructor(options, name, shouldEnablePersistence, settings, \n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n        this.schedulers = schedulers;\n        const app = _firebaseAppFactory(options, zone, name);\n        const useEmulator = _useEmulator;\n        if (auth) {\n            _authFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n        }\n        [this.firestore, this.persistenceEnabled$] = _cacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n            const firestore = zone.runOutsideAngular(() => app.firestore());\n            if (settings) {\n                firestore.settings(settings);\n            }\n            if (useEmulator) {\n                firestore.useEmulator(...useEmulator);\n            }\n            if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n                // We need to try/catch here because not all enablePersistence() failures are caught\n                // https://github.com/firebase/firebase-js-sdk/issues/608\n                const enablePersistence = () => {\n                    try {\n                        return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n                    }\n                    catch (e) {\n                        if (typeof console !== 'undefined') {\n                            console.warn(e);\n                        }\n                        return of(false);\n                    }\n                };\n                return [firestore, zone.runOutsideAngular(enablePersistence)];\n            }\n            else {\n                return [firestore, of(false)];\n            }\n        }, [settings, useEmulator, shouldEnablePersistence]);\n    }\n    collection(pathOrRef, queryFn) {\n        let collectionRef;\n        if (typeof pathOrRef === 'string') {\n            collectionRef = this.firestore.collection(pathOrRef);\n        }\n        else {\n            collectionRef = pathOrRef;\n        }\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        const refInZone = this.schedulers.ngZone.run(() => ref);\n        return new AngularFirestoreCollection(refInZone, query, this);\n    }\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     */\n    collectionGroup(collectionId, queryGroupFn) {\n        const queryFn = queryGroupFn || (ref => ref);\n        const collectionGroup = this.firestore.collectionGroup(collectionId);\n        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n    doc(pathOrRef) {\n        let ref;\n        if (typeof pathOrRef === 'string') {\n            ref = this.firestore.doc(pathOrRef);\n        }\n        else {\n            ref = pathOrRef;\n        }\n        const refInZone = this.schedulers.ngZone.run(() => ref);\n        return new AngularFirestoreDocument(refInZone, this);\n    }\n    /**\n     * Returns a generated Firestore Document Id.\n     */\n    createId() {\n        return this.firestore.collection('_').doc().id;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestore, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: ENABLE_PERSISTENCE, optional: true }, { token: SETTINGS, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: PERSISTENCE_SETTINGS, optional: true }, { token: USE_EMULATOR, optional: true }, { token: i2.AngularFireAuth, optional: true }, { token: USE_EMULATOR$1, optional: true }, { token: SETTINGS$1, optional: true }, { token: TENANT_ID, optional: true }, { token: LANGUAGE_CODE, optional: true }, { token: USE_DEVICE_LANGUAGE, optional: true }, { token: PERSISTENCE, optional: true }, { token: i3.AppCheckInstances, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestore, providedIn: 'any' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestore, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'any'\n                }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FIREBASE_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FIREBASE_APP_NAME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ENABLE_PERSISTENCE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [SETTINGS]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [PERSISTENCE_SETTINGS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR]\n                }] }, { type: i2.AngularFireAuth, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR$1]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [SETTINGS$1]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TENANT_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [LANGUAGE_CODE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_DEVICE_LANGUAGE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [PERSISTENCE]\n                }] }, { type: i3.AppCheckInstances, decorators: [{\n                    type: Optional\n                }] }] });\n\nclass AngularFirestoreModule {\n    constructor() {\n        firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n    }\n    /**\n     * Attempt to enable persistent storage, if possible\n     */\n    static enablePersistence(persistenceSettings) {\n        return {\n            ngModule: AngularFirestoreModule,\n            providers: [\n                { provide: ENABLE_PERSISTENCE, useValue: true },\n                { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n            ]\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestoreModule });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestoreModule, providers: [AngularFirestore] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.0\", ngImport: i0, type: AngularFirestoreModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [AngularFirestore]\n                }]\n        }], ctorParameters: () => [] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}